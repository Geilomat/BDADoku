%How it will be Implemented

%\section{Tipps/Notes}
%make plots from the different sensors and the log data to show how it was 
%produced an how it resembles the real data.
%The simulation itself is implemented in Matlab as different .m files.

\section{Sensor Models}
How the concept of the different sensor models work is described in chapter \ref{ch:Approach}.
Following here, the implementation which is used in the simulation will be stated in detail.
First in general for all sensors, following by the different characteristics of each sensor.

\subsection{Perfect Sensor}
In general, the perfect sensor data are calculated like stated in chapter \ref{ch:Approach}.
In figure \ref{fig:GeneratedPerfectSensor} those generated sensor data as well as the trajectory used for this can be seen.

\begin{figure}[h!]
 \centering
 \includegraphics[width=0.8\textwidth]{./Pictures/GeneratedSensorData.jpg}
 % GeneratedSensorData.jpg: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{Generated sensor data}
 \label{fig:GeneratedPerfectSensor}
\end{figure}

\subsubsection{Accelorometer}
Due to the fact that whole simulation works with discreet time stamps, the derivative of the height can not be done formally.
So it is done by calculating the difference in each data point to the next and then weight those by the delta in time between them.
This has to be done two times to get from the height to the acceleration.
The unit for the acceloration in this simulation is meter per second squared.

\subsubsection{Gyrometer}
As stated before the pitch angle can not be directly generated.
But if the  data from the test flights are visited. It can be seen that the angle stays more or less the same wile the motor is burning.
This make sense because during this time the main acceleration comes from one determinet direction and stabilices the rocket.
After the burnout the pitch angle does change more or less randomly depending on strength and direction of the wind that hits the rocket.
To reanimate this the values are generated randomly and the low pass filtered with a moving average filter to represent that behaviour.
While doing this the random values are kept small during the burning of the motor and exceed afterwards to higher values.

\subsubsection{Barometer}
The measurements from the barometer are depending on the formula stated in chapter \ref{ch:Approach}.
For reasons of simlicity the start pressure is choosen as the mean pressure at sea level which is 1013.35 hPa.
Also the temperature at the beginning is chosen as 288.15 degree Kelvin (15 degree Celcius) which also represents the mean value on the sea level.
At least the temperature gradient is - 0.0065 Â°/m which is a common used value.
For the state estimation in a test flight those values have to be determined before the start.

\subsubsection{GPS}
As stated in chapter \ref{ch:Approach} the GPS signal is just the height with a different sampling time. 
To maintain the vectors length which simplifies the later use in the estimation algorithm,
the signal is acquired with a zero order hold conversion instead of a down sampling. 

% Add code for the zero order Holde convertion

\subsection{Noise}
To generate the noise out of the data from the test flight, this has first to be extracted.
It is assumed that the noise on the data is different depending on the state of the rocket (before Icognition, during motor burning, after burnout till parachute ejection),
but it should have more or less the same properties between those events.
Depending on this, the data vector have first to be separated in those different sections.
For this the accelorometer measurements are iterated to find the time stamps on which those events happen like in figure \ref{fig:AccelerationMarks}.

%% picture of acceloration of z axis with icognition, burnout and parachute ejection are marked
\begin{figure}[h!]
 \centering
 \includegraphics[width=0.8\textwidth]{./Pictures/AccelerationMarks.jpg}
 % AccelerationMarks.pdf: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{Timestamps drawn out of acceleration measurements}
 \label{fig:AccelerationMarks}
\end{figure}


If done so, polynoms are fitted on this measurements with the least squared error method.
Those polynoms represent the function which is assumed to be the noiseless data with possible offsets.
So if now the test flight data is subtracted by those polynomial curves which results in the noise without a mean.
From this point on this noise can be examined on its parameters, like the power density, the probability distribution and the variance figure \ref{fig:PF_AC_HIST_Accel}.

%% pictue of autocorrelation, histogramm etc from sensor data noise
\begin{figure}[h!]
 \centering
 \includegraphics[width=0.8\textwidth]{./Pictures/PF_AC_HIST_Accel.jpg}
 % PF_AC_HIST_Accel.jpg: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{Polyfit Autoccorellation and Histogramm}
 \label{fig:PF_AC_HIST_Accel}
\end{figure}


This noise data can now used tho solve the yule walker equation to get an AR-model.
For this the aryule function in can be used which estimates an AR-model of the order N as well as the variance directly out of the noise vector.
But first, the data has to be resampled so that the AR-models can be used proper in the simulation.
With those AR-models, the noise can be regenerated by filtering white noise with the correct variance.
This generated noise can now be compared to the noise form the test flight data.

%% picture of pwelch plot from both noise vectors
\begin{figure}[h!]
 \centering
 \includegraphics[width=0.8\textwidth]{./Pictures/PDSnoise.jpg}
 % PDSnoise.jpg: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{PDS form the measured and generated noise}
 \label{fig:PDSNoise}
\end{figure}


As seen in figure \ref{fig:PDSNoise} those noise resemble each other in their power density spectrum much more than the white noise would.
So this AR-model is exported to the simulation script and can be used there to generate the real sensor data.

\subsubsection{Accelorometer}
The noise which is on the accelorometer is special because it often has a drift which results in a more or less constant offset.
To recreate this, the offset can be estimated from the test flight data.
Especially the data before the ignition are help full, because the value that should be measured is known.

\subsubsection{Gyrometer}
For the gyrometer noise a seperat skript was written to calculate the proper pitch angle and filter out the offset before-
% Do this better as it is now

\subsubsection{Barometer}
First there are two or more barometer which sample on different frequencies ant have therefore also different accuracy's.
This is represented in the way that the variance of the noise from the slower sampled barometer is kept on a smaller value,
than that of the sensor which is faster sampled.

\subsubsection{GPS}
The GPS noise capacities were found with measurements that were taken for a longer time period while the GPS receiver at the same place.
So the noise will have the same capacities over the whole flight.
This due to the assumption that the GPS measurements should be independent from the motors vibration and the rockets posture changes.
This should be suitable as long as the receiver does not lose its fix.

\subsection{Real Sensor}
To now generated the real sensor data, the different noises have to be generated like stated above.
For this a vector of normal distributed random values is generated and multiplied by the square root of the corresponding variance.
This white noise is now filtered by the corresponding AR-model and can then be added onto the corresponding perfect sensor data.
This now results in the real sensor data.

%Insert here pictures from the real sensor data and discuss how it looks and why:
\subsubsection{Accelorometer}


\subsubsection{Gyrometer}


\subsubsection{Barometer}


\subsubsection{GPS}



\section{State Estimation} %% Do this maybe in introduction because it is not specific to this simulation
% As stated the used state estimator is a kalman filter with dynamic noises on the system as well as on the measurements.
% This algorithm works in 4 main equations which can be devided into prediction and correction steps figure \ref{fig:Kalmanfilter}.
% 
% \begin{figure}[h!]
%   \centering
%   \includegraphics[width = \textwidth]{../BDADoku/Pictures/KalFIlFunc.pdf}
%   \caption{Kalmanfilter}
%   \label{fig:Kalmanfilter}
% \end{figure}
% 
% \subsection{Prediction}
% The prediction equations take the currently values of the state vector ($x[k]$)
% and uses the time depending system model part (A) to predict the state values for the next time step $\hat{x}[k+1]$.
% The hat denotes that this value is an assumption.
% This with the equation: $$ \hat{x}[k+1] = AD*x[k] + Bd*u[k] $$
% In addition the certainty matrix (P) is calculated which means that it is calculated how trustwotrhy those predictions are.
% $$ P = Ad*P*Ad' + Gd*Q[k]*Gd'$$
% For this the system noise is used, so with the help of the Q matrix it can be stated how well known the system is in this
% time step.
% 
% \subsection{Correction Step}
% If the measurements arrive those will be used can be used in the correction step to correct the prediction.
% First the Kalmangain (K) is calculated with the equation.
% $$ K = P*C'*(C*P*C' + R[k])^{(-1)} $$ 
% This uses the P matrix from the prediction step as well as the R matrix which represents the measurments noise (how certain the values from the measurements are).
% K is then used in the last equation $$x[k] = \hat{x}[k] + K*(y[k] - C*\hat{x}[k]-Dd*u[k])$$.
% With this the measurement is used to correct the predicted value of the state vector with there uncertainties taken into account 
% 
% For this the matrices for the system models (A,B,C,D), the measurements noise (Q) as well as the system noises (R) have to be defined.
As stated the used state estimator is a kalman filter with dynamic noises in the measurements as well in the systems.
For this the noise matrices as well as the used loop is described below.

\subsection{System Model}
The models are modelled as stated in chapter \ref{ch:Approach} but from this different uses can be made out of this.
For this simulation bla models were implemented with each different capability.

Due to this, these different implementation are tested and evaluated in the next chapter.
\subsection{Adjustment}
% Acel offset and accel as input 

\subsection{Measurements noise}
The measurement noise matrix on each timestamp is easy to get in this simulation because the perfect measurements are known.
%First one variance per data vector can be used to simplify the whole process but this should not be too accurate.

%As a second possibility the variance can be calculated different for before and after burnout.
First the variance over the burning of the motor as well as over the up flight is calculated.
After that those values are used to generate a noise vector for each measurements.
In addition in the implementation the noise vector have the same length as all other used vectors.
But because not all 

These noise measurements are then catognated into a diagonal noise matrices.
If the noise matrix is displayed as a diagonal matrix, 
it equals in the assumption that the noises from the measurements are independent from each other.
This assumption can be made cause of the fact that each measurements expected those from the barometer are made from different sensors.
The barometer measurements are the pressure as well as the temperature.
Due to the fact that the temperature is not used for the state estimation, the measurements matrix can still be assumed as diagonal.



\subsection{System noises}
For the system noise the behaviour of the system during the flight has to be examinated.
And after that it has to be implemented as good as possible.
For an example the acceleration which is most times modeled as stable with a little system noise on it,
has to have a lot of noise during the ignition and also during the burnout because it changes a lot there.

The best solution was found in diffiating the corresponding values and then low pass filtering it with an IIR moving average filter like this;




\subsection{Loop}
Finally the state estimation is implemented in a simple loop which iterates trough each given time stamp.
First the needed vectors and matrices have to be initialised with the right value.
In the most system model versions the u vector remains zero while all measurements are brought into the estimation loop trough the y vector.
In the others the acceleration and the pitch angle are brought into the estimation loop over the u vector an the remaining measurements trough the y vector.
Also the current state vector x has to be initialised with the value that those states have at the start, 
which is presumably zero for all states except pressure and temperature.\\
The loop itself calculates the equation as they were stated in chapter \ref{ch:Approach}.
In addition if values from the measurements can not be transformed into the state vector values directly or with a linear calculation,
they have to be transformed first before entering the system.
For example pressure and temperature into height or acceleration and pitch angle into pure vertical acceleration.\\
Below is an example for the estimation loop for a rank five system.
It contains height, speed, acceleration, acceleration offset and pitch angle as state variables.
\begin{lstlisting}[caption={State Estimation Loop}]
% Initalzation
u = zeros(1,length(TimeVec));                       %Input vector is zero
y = [h_mes_GPS;a_mes;p_mes_1;p_mes_2;phi_mes];      %Output are the measurements
x = [0;0;0;0;0];                                    %Start Vector should be like this
P = eye(5);                                         %Standart can maybe be increased
Height1 = 0;
Height2 = 0;
Temp = T(1);

% Estimation loop
x_est_loop3 = zeros(size(x,1),length(TimeVec));     %Vector for the SE values
for k = 1:length(TimeVec)
    K = P*C'*pinv(C*P*C' + R_dyn_m(:,:,k));
    Height1 = CalcHeight(Po,p_mes_1(k),Temp,0,true,TgradSimu);
    Height2 = CalcHeight(Po,p_mes_2(k),Temp,0,true,TgradSimu);
    acc = a_mes(k) * cos(x(5)*pi/180);
    x = x + K*([h_mes_GPS(k);acc;Height1;Height2;phi_mes(k)] - C*x);
    P = (eye(5)-K*C)*P;
    
    x_est_loop3(:,k) = x;                           %Save data from the Sensor fusion
    
    x = Ad*x + Bd*u(k);
    P = Ad*P*Ad' + Gd*Q_dyn_m(:,:,k)*Gd';

end
\end{lstlisting}

